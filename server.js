const express = require('express');
const app = express();
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const cors = require('cors');
const expressSanitizer = require('express-sanitizer');

const { databaseConnection } = require('./database/databaseConnection');
const {
	customErrorMiddleware,
} = require('./middleware/handlers/customErrorMiddleware');

require('dotenv').config();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser(process.env.WALKERS_SHORTBREAD));
app.use(expressSanitizer());
app.use(helmet());

app.use(
	cors({
		origin: process.env.FRONTEND_PORT,
		methods: ['GET', 'POST', 'PATCH', 'DELETE'],
		credentials: true,
	})
);

databaseConnection();

const authenticationRoute = require('./routes/authenticationRoute');
app.use('/authentication', authenticationRoute);

app.get('/', (req, res) => {
	res.send('homepage');
});

app.use(customErrorMiddleware);

app.listen(process.env.PORT, () => {
	console.log(`App listening on port ${process.env.PORT}!`);
});

/*

--- NOTES ---

Maybe we can keep user authentication with JWT cookies and then some other meaningful data in sessions.
1.Do something meaningful with sessions aside from jwt cookie things.

JWT Cookie for user auth
CSRFToken in header for CSRF things - Maybe use assymetric JWT verifying from frontend to backend. Frontend will send this via fetch or axios. use frontend .env file to store key backend will verify and then confirm action

Redis session for refresh and access tokens

All the session things will be in req.session . this is nice because it can be hidden and just stored in one thing. before we had three cookies to store currentUser,currentProject & currentPhase, now we can just append the id id to the sesson.

No need to flush the database as long as an expiration date will be set.

CSRF TOKENS
	- Token is used in making modifying requests(POST,PUT,PATCH,DELETE)
	- JWT Token generated by the frontend with key in .env file
	- Sent through the header
	- Server uses asymetric JWT Validation
	- If token is valid, proceed with the action.
	- Custom header with JWT value encrypted with private key and then verified with public key on the frontend
	

SESSION TOKEN
	- Token/Session is used in establishing user session
	- Browser hits API, session is established.
	- Session expires every 2 hours upon establishment.
	- The following data are to be stored in sessions :
		- User Authentication - Maybe also in the form of a JWT cookie or just a bcrypt hash
		- User Authorization
		- Current Project
		- Current Phase
		- User email for access and refresh cookies
	- Established upon the validity of the Access and Refresh Token which contains the payload.

REFRESH TOKEN
	- JWT Cookie that stays in the browser for 2/4 weeks 
	- If Expired and/or changes made to user account, user must log in again.
	- Must be invalidated once there are changes in the user account.
	- Everytime user logs inor refresh token expires user must be given a new userAuthToken
	- Cookie sent by the server encrypted with a private key and then verified on succeeding routes using a public key

ACCESS TOKEN
	- JWT Cookie that expires every 10/60 min
	- Access token is always sent to the server :
		- Browser sends access token to server
		- server checks if both refresh token and access token are valid
	- Contains the userAuth token in the payload
	- Explore if the payload can be timestamped or something dynamic

REFRESH TOKEN & ACCESS TOKEN RELATIONSHIP
	- Refresh token - VALID
		- proceed with process.

	- Refresh & Access must both be valid before any procedure.

	- Access Token - Valid , Refresh Token - Valid.
		- Proceed

	- Access Token-Valid , Refresh Token-Expired.
		- Log In Again.
		- Server sends new Refresh Token & Access Token

	- Access Token-Expired , Refresh Token-Valid.
		- Server sends new Access Token

	- Access Token-Expired , Refresh Token-Expired.
		- Log In Again.
		- Server sends new Refresh Token & Access Token

	- Access Token-Valid , Refresh Token-Valid , Session Token-Expired
		- Send new valid session token

Access token acts as your hotel key. even if yu are no longer checked in. the hotel/access key technically is still valid.
Refresh token acts as your frontdesk/cctv/fingerprint validation such that it is only valid up until you checkout.
Both refresh and access token needs to be valid in order for you to complete the procedure.
Consider storing key files in private.key(server) and public.key(frontend)

***** EVERY REQUEST MUST CHECK IF THE FF ARE VALID *****
	- User Authentication
	- User Authorization
	- REFRESH TOKEN
	- ACCESS TOKEN

***** EVERY PUT,POST,PATCH,DELETE REQUEST MUST CHECK IF THE FF ARE VALID *****
	- User Authentication
	- User Authorization
	- REFRESH TOKEN
	- ACCESS TOKEN
	- CSURF TOKEN


^^^^^^^ Points to remmeber ^^^^^^^
Refresh Token depends on user Log In
Session and Access Token DEPENDS on Refresh Token
CSRF Header depends on Refresh Token,Session & Access Token (not yet sure to or just jwt verification na separate per method maybe)

Server must check this in order per hit.
	- Refresh Token
	- Access Token
	- Session Token
	- CSRF Header (on necessary routes)

*/
